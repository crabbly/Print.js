/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict'\n\nvar browser = __webpack_require__(1)\n\nvar printTypes = ['pdf', 'html', 'image', 'json']\n\nvar defaultParams = {\n  printable: null,\n  type: 'pdf',\n  header: null,\n  maxWidth: 800,\n  font: 'TimesNewRoman',\n  font_size: '12pt',\n  honorMarginPadding: true,\n  honorColor: false,\n  properties: null,\n  showModal: false,\n  modalMessage: 'Retrieving Document...',\n  frameId: 'printJS',\n  border: true,\n  htmlData: ''\n}\n\nvar printFriendlyElement, bodyStyle, headerStyle\n\nmodule.exports = function () {\n  // check if a printable document or object was supplied\n  if (arguments[0] === undefined) {\n    window.console.error('printJS expects at least 1 attribute.')\n    return false\n  }\n\n  // instantiate print object\n  var printJS = new PrintJS(arguments)\n\n  // print friendly defaults\n  printFriendlyElement = 'max-width: ' + printJS.params.maxWidth + 'px !important;' + printJS.params.font_size + ' !important;'\n  bodyStyle = 'font-family:' + printJS.params.font + ' !important; font-size: ' + printJS.params.font_size + ' !important; width:100%;'\n  headerStyle = 'font-weight:300;'\n\n  // check printable type\n  switch (printJS.params.type) {\n    case 'pdf':\n          // firefox doesn't support iframe printing, we will just open the pdf file instead\n      if (browser.isFirefox()) {\n        console.log('PrintJS doesn\\'t support PDF printing in Firefox.')\n        var win = window.open(printJS.params.printable, '_blank')\n        win.focus()\n              // make sure there is no loading modal opened\n        if (printJS.params.showModal) printJS.disablePrintModal()\n      } else {\n        printJS.pdf()\n      }\n      break\n    case 'image':\n      printJS.image()\n      break\n    case 'html':\n      printJS.html()\n      break\n    case 'json':\n      printJS.json()\n      break\n    default:\n          // throw invalid type error\n      throw new Error('Invalid print type. Available types are: pdf, html, image and json.')\n  }\n}\n\n// printJS class\nvar PrintJS = function () {\n  var args = arguments[0]\n\n  var print = this\n\n  print.params = extend({}, defaultParams)\n\n  switch (typeof args[0]) {\n    case 'string':\n      print.params.printable = encodeURI(args[0])\n      print.params.type = args[1] || defaultParams.type\n      break\n\n    case 'object':\n      print.params.printable = args[0].printable\n      print.params.type = args[0].type || defaultParams.type\n      print.params.frameId = args[0].frameId || defaultParams.frameId\n      print.params.header = args[0].header || defaultParams.header\n      print.params.maxWidth = args[0].maxWidth || defaultParams.maxWidth\n      print.params.font = args[0].font || defaultParams.font\n      print.params.font_size = args[0].font_size || defaultParams.font_size\n      print.params.honorMarginPadding = (typeof args[0].honorMarginPadding !== 'undefined') ? args[0].honorMarginPadding : defaultParams.honorMarginPadding\n      print.params.properties = args[0].properties || defaultParams.properties\n      print.params.showModal = (typeof args[0].showModal !== 'undefined') ? args[0].showModal : defaultParams.showModal\n      print.params.modalMessage = args[0].modalMessage || defaultParams.modalMessage\n      break\n\n    default:\n      throw new Error('Unexpected argument type! Expected \"string\" or \"object\", got ' + typeof args[0])\n  }\n\n  // some validation\n  print.validateInput()\n\n  // check if showing feedback to user (useful for large files)\n  if (print.params.showModal) {\n    print.showModal()\n  }\n\n  // to prevent duplication and issues, remove print.printFrame from DOM, if it exists\n  var usedFrame = document.getElementById(print.params.frameId)\n\n  if (usedFrame) {\n    usedFrame.parentNode.removeChild(usedFrame)\n  }\n\n  // create a new iframe or embed element (IE prints blank pdf's if we use iframe)\n  if (browser.isIE() && print.params.type === 'pdf') {\n    // create embed element\n    print.printFrame = document.createElement('embed')\n    print.printFrame.setAttribute('type', 'application/pdf')\n\n    // hide embed\n    print.printFrame.setAttribute('style', 'width:0px;height:0px;')\n  } else {\n    // create iframe element\n    print.printFrame = document.createElement('iframe')\n\n    // hide iframe\n    print.printFrame.setAttribute('style', 'display:none;')\n  }\n\n  // set element id\n  print.printFrame.setAttribute('id', print.params.frameId)\n\n  // for non pdf printing, pass empty html document to srcdoc (force onload callback)\n  if (print.params.type !== 'pdf') print.printFrame.srcdoc = '<html><head></head><body></body></html>'\n}\n\nPrintJS.prototype.pdf = function () {\n  var print = this\n\n  // if showing feedback to user, pre load pdf files (hacky)\n  // since we will be using promises, we can't use this feature in IE\n  if (print.params.showModal && !browser.isIE()) {\n    var pdfObject = document.createElement('img')\n    pdfObject.src = print.params.printable\n\n    var pdf = new Promise(function (resolve, reject) {\n      var loadPDF = setInterval(checkPDFload, 100)\n\n      function checkPDFload () {\n        if (pdfObject.complete) {\n          window.clearInterval(loadPDF)\n          resolve('PrintJS: PDF loaded. Read to print.')\n        }\n      }\n    })\n\n    pdf.then(function (result) {\n      console.log(result)\n      // set iframe src with pdf document url\n      print.printFrame.setAttribute('src', print.params.printable)\n\n      // print pdf document\n      print.print()\n    })\n  } else {\n    // set iframe src with pdf document url\n    print.printFrame.setAttribute('src', print.params.printable)\n\n    // print pdf\n    print.print()\n  }\n}\n\nPrintJS.prototype.image = function () {\n  // create the image element\n  var img = document.createElement('img')\n  img.setAttribute('style', 'width:100%;')\n  img.setAttribute('id', 'printableImage')\n\n  // set image src with image file url\n  img.src = this.params.printable\n\n  // assign `this` to a variable, to be used within the promise, and functions\n  var self = this\n\n  // create wrapper\n  var printableElement = document.createElement('div')\n  printableElement.setAttribute('style', 'width:100%')\n\n  // to prevent firefox from not loading images within iframe, we can use base64-encoded data URL of images pixel data\n  if (browser.isFirefox()) {\n    // let's make firefox happy\n    var canvas = document.createElement('canvas')\n    canvas.setAttribute('width', img.width)\n    canvas.setAttribute('height', img.height)\n    var context = canvas.getContext('2d')\n    context.drawImage(img, 0, 0)\n\n    // reset img src attribute with canvas dataURL\n    img.setAttribute('src', canvas.toDataURL('JPEG', 1.0))\n  }\n\n  printableElement.appendChild(img)\n\n  // add header if any\n  if (self.params.header) {\n    self.addHeader(printableElement)\n  }\n\n  // store html data\n  self.params.htmlData = printableElement.outerHTML\n\n  // print image\n  self.print()\n}\n\nPrintJS.prototype.html = function () {\n  // get HTML printable element\n  var printElement = document.getElementById(this.params.printable)\n\n  // check if element exists\n  if (!printElement) {\n    window.console.error('Invalid HTML element id: ' + this.params.printable)\n\n    return false\n  }\n\n  // make a copy of the printElement to prevent DOM changes\n  var printableElement = document.createElement('div')\n  printableElement.appendChild(printElement.cloneNode(true))\n\n  // add cloned element to DOM, to have DOM element methods available. It will also be easier to colect styles\n  printableElement.setAttribute('style', 'display:none;')\n  printableElement.setAttribute('id', 'printJS-html')\n  printElement.parentNode.appendChild(printableElement)\n\n  // update printableElement variable with newly created DOM element\n  printableElement = document.getElementById('printJS-html')\n\n  // get main element styling\n  printableElement.setAttribute('style', this.collectStyles(printableElement) + 'margin:0 !important;')\n\n  // get all children elements\n  var elements = printableElement.children\n\n  // get styles for all children elements\n  this.loopNodesCollectStyles(elements)\n\n  // add header if any\n  if (this.params.header) {\n    this.addHeader(printableElement)\n  }\n\n  // remove DOM printableElement\n  printableElement.parentNode.removeChild(printableElement)\n\n  // store html data\n  this.params.htmlData = addWrapper(printableElement.innerHTML)\n\n  // print html element contents\n  this.print()\n}\n\nPrintJS.prototype.json = function () {\n   // check if we received proper data\n  if (typeof this.params.printable !== 'object') {\n    throw new Error('Invalid javascript data object (JSON).')\n  }\n\n  // check if properties were provided\n  if (!this.params.properties || typeof this.params.properties !== 'object') {\n    throw new Error('Invalid properties array for your JSON data.')\n  }\n\n  // variable to hold html string\n  var htmlData = ''\n\n  // check print has header\n  if (this.params.header) {\n    htmlData += '<h1 style=\"' + headerStyle + '\">' + this.params.header + '</h1>'\n  }\n\n  // function to build html templates for json data\n  htmlData += this.jsonToHTML()\n\n  // store html data\n  this.params.htmlData = addWrapper(htmlData)\n\n  // print json data\n  this.print()\n}\n\nPrintJS.prototype.print = function () {\n  var print = this\n\n  // append iframe element to document body\n  document.getElementsByTagName('body')[0].appendChild(print.printFrame)\n\n  // get iframe element\n  var printJS = document.getElementById(print.params.frameId)\n\n  // if printing pdf in IE\n  if (browser.isIE() && print.params.type === 'pdf') {\n    finishPrintPdfIe()\n  } else {\n    // wait for iframe to load all content\n    print.printFrame.onload = function () {\n      if (print.params.type === 'pdf') {\n        finishPrint()\n      } else {\n        // get iframe element document\n        var printDocument = (printJS.contentWindow || printJS.contentDocument)\n        if (printDocument.document) printDocument = printDocument.document\n\n        // inject printable html into iframe body\n        printDocument.body.innerHTML = print.params.htmlData\n\n        // wait for image to load inside iframe (chrome only)\n        if (print.params.type === 'image' && browser.isChrome()) {\n          printDocument.getElementById('printableImage').onload = function () {\n            finishPrint()\n          }\n        } else {\n          finishPrint()\n        }\n      }\n    }\n  }\n\n  function finishPrint () {\n    // print iframe document\n    printJS.focus()\n\n    // if IE, try catch with execCommand\n    if (browser.isIE() && print.params.type !== 'pdf') {\n      try {\n        printJS.contentWindow.document.execCommand('print', false, null)\n      } catch (e) {\n        printJS.contentWindow.print()\n      }\n    } else {\n      printJS.contentWindow.print()\n    }\n\n    // if showing feedback to user, remove processing message (close modal)\n    if (print.params.showModal) {\n      print.disablePrintModal()\n    }\n  }\n\n  function finishPrintPdfIe () {\n    // wait until pdf is ready to print\n    if (typeof printJS.print === 'undefined') {\n      setTimeout(function () { finishPrintPdfIe() }, 1000)\n    } else {\n      printJS.print()\n\n      // remove embed (just because it isn't 100% hidden when using h/w = 0)\n      setTimeout(function () { printJS.parentNode.removeChild(printJS) }, 2000)\n    }\n  }\n}\n\nPrintJS.prototype.collectStyles = function (element) {\n  var this$1 = this;\n\n  var win = document.defaultView || window\n\n  var style = []\n\n  // string variable to hold styling for each element\n  var elementStyle = ''\n\n  if (win.getComputedStyle) { // modern browsers\n    style = win.getComputedStyle(element, '')\n\n    for (var i = 0; i < style.length; i++) {\n      // styles including\n      var targetStyles = ['border', 'float', 'box']\n\n      // exact\n      var targetStyle = ['clear', 'display', 'width', 'min-width', 'height', 'min-height', 'max-height']\n\n      // optinal - include margin and padding\n      if (this$1.params.honorMarginPadding) {\n        targetStyle.push('margin', 'padding')\n      }\n\n      // optinal - include color\n      if (this$1.params.honorColor) {\n        targetStyle.push('color')\n      }\n\n      for (var s = 0; s < targetStyle.length; s++) {\n        if (style[i].indexOf(targetStyles[s]) !== -1 || style[i].indexOf(targetStyle[s]) === 0) {\n          elementStyle += style[i] + ':' + style.getPropertyValue(style[i]) + ';'\n        }\n      }\n    }\n  } else if (element.currentStyle) { // IE\n    style = element.currentStyle\n\n    for (var name in style) {\n      if (style.indexOf('border') !== -1 && style.indexOf('color') !== -1) {\n        elementStyle += name + ':' + style[name] + ';'\n      }\n    }\n  }\n\n  // add printer friendly\n  elementStyle += printFriendlyElement\n\n  return elementStyle\n}\n\nPrintJS.prototype.loopNodesCollectStyles = function (elements) {\n  var this$1 = this;\n\n  for (var n = 0; n < elements.length; n++) {\n    var currentElement = elements[n]\n\n    // Form Printing - check if is element Input\n    var tag = currentElement.tagName\n    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') {\n      // save style to variable\n      var textStyle = this$1.collectStyles(currentElement)\n\n      // remove INPUT element and insert a text node\n      var parent = currentElement.parentNode\n\n      // get text value\n      var textNode = tag === 'SELECT'\n              ? document.createTextNode(currentElement.options[currentElement.selectedIndex].text)\n              : document.createTextNode(currentElement.value)\n\n      // create text element\n      var textElement = document.createElement('div')\n      textElement.appendChild(textNode)\n\n      // add style to text\n      textElement.setAttribute('style', textStyle)\n\n      // add text\n      parent.appendChild(textElement)\n\n      // remove input\n      parent.removeChild(currentElement)\n    } else {\n      // get all styling for print element\n      currentElement.setAttribute('style', this$1.collectStyles(currentElement))\n    }\n\n    // check if more elements in tree\n    var children = currentElement.children\n\n    if (children.length) {\n      this$1.loopNodesCollectStyles(children)\n    }\n  }\n}\n\nPrintJS.prototype.addHeader = function (printElement) {\n  // create header element\n  var headerElement = document.createElement('h1')\n\n  // create header text node\n  var headerNode = document.createTextNode(this.params.header)\n\n  // build and style\n  headerElement.appendChild(headerNode)\n  headerElement.setAttribute('style', headerStyle)\n\n  printElement.insertBefore(headerElement, printElement.childNodes[0])\n}\n\nPrintJS.prototype.jsonToHTML = function () {\n  var this$1 = this;\n\n  var data = this.params.printable\n  var properties = this.params.properties\n\n  var htmlData = '<div style=\"display:flex; flex-direction: column;\">'\n\n  // header\n  htmlData += '<div style=\"flex:1; display:flex;\">'\n\n  for (var a = 0; a < properties.length; a++) {\n    htmlData += '<div style=\"flex:1; padding:5px;\">' + capitalizePrint(properties[a]) + '</div>'\n  }\n\n  htmlData += '</div>'\n\n  // create html data\n  for (var i = 0; i < data.length; i++) {\n    htmlData += '<div style=\"flex:1; display:flex;'\n    htmlData += this$1.params.border ? 'border:1px solid lightgray;' : ''\n    htmlData += '\">'\n\n    for (var n = 0; n < properties.length; n++) {\n      htmlData += '<div style=\"flex:1; padding:5px;\">' + data[i][properties[n]] + '</div>'\n    }\n\n    htmlData += '</div>'\n  }\n\n  htmlData += '</div>'\n\n  return htmlData\n}\n\nPrintJS.prototype.validateInput = function () {\n  if (!this.params.printable) {\n    throw new Error('Missing printable information.')\n  }\n\n  if (!this.params.type || typeof this.params.type !== 'string' || printTypes.indexOf(this.params.type.toLowerCase()) === -1) {\n    throw new Error('Invalid print type. Available types are: pdf, html, image and json.')\n  }\n}\n\nPrintJS.prototype.showModal = function () {\n  // build modal\n  var modalStyle = 'font-family:sans-serif; ' +\n      'display:table; ' +\n      'text-align:center; ' +\n      'font-weight:300; ' +\n      'font-size:30px; ' +\n      'left:0; top:0;' +\n      'position:fixed; ' +\n      'z-index: 9990;' +\n      'color: #0460B5; ' +\n      'width: 100%; ' +\n      'height: 100%; ' +\n      'background-color:rgba(255,255,255,.9);' +\n      'transition: opacity .3s ease;'\n\n  // create wrapper\n  var printModal = document.createElement('div')\n  printModal.setAttribute('style', modalStyle)\n  printModal.setAttribute('id', 'printJS-Modal')\n\n  // create content div\n  var contentDiv = document.createElement('div')\n  contentDiv.setAttribute('style', 'display:table-cell; vertical-align:middle; padding-bottom:100px;')\n\n  // add close button (requires print.css)\n  var closeButton = document.createElement('div')\n  closeButton.setAttribute('class', 'printClose')\n  closeButton.setAttribute('id', 'printClose')\n  contentDiv.appendChild(closeButton)\n\n  // add spinner (requires print.css)\n  var spinner = document.createElement('span')\n  spinner.setAttribute('class', 'printSpinner')\n  contentDiv.appendChild(spinner)\n\n  // add message\n  var messageNode = document.createTextNode(this.params.modalMessage)\n  contentDiv.appendChild(messageNode)\n\n  // add contentDiv to printModal\n  printModal.appendChild(contentDiv)\n\n  // append print modal element to document body\n  document.getElementsByTagName('body')[0].appendChild(printModal)\n\n  // add event listener to close button\n  var print = this\n  document.getElementById('printClose').addEventListener('click', function () {\n    print.disablePrintModal()\n  })\n}\n\nPrintJS.prototype.disablePrintModal = function () {\n  var printFrame = document.getElementById('printJS-Modal')\n\n  printFrame.parentNode.removeChild(printFrame)\n}\n\nfunction addWrapper (htmlData) {\n  return '<div style=\"' + bodyStyle + '\">' + htmlData + '</div>'\n}\n\n// update default print.params with user input\nfunction extend (a, b) {\n  for (var key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key]\n    }\n  }\n\n  return a\n}\n\n// capitalize string\nfunction capitalizePrint (string) {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvaW5kZXguanM/OTlhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuXG5sZXQgcHJpbnRUeXBlcyA9IFsncGRmJywgJ2h0bWwnLCAnaW1hZ2UnLCAnanNvbiddXG5cbmxldCBkZWZhdWx0UGFyYW1zID0ge1xuICBwcmludGFibGU6IG51bGwsXG4gIHR5cGU6ICdwZGYnLFxuICBoZWFkZXI6IG51bGwsXG4gIG1heFdpZHRoOiA4MDAsXG4gIGZvbnQ6ICdUaW1lc05ld1JvbWFuJyxcbiAgZm9udF9zaXplOiAnMTJwdCcsXG4gIGhvbm9yTWFyZ2luUGFkZGluZzogdHJ1ZSxcbiAgaG9ub3JDb2xvcjogZmFsc2UsXG4gIHByb3BlcnRpZXM6IG51bGwsXG4gIHNob3dNb2RhbDogZmFsc2UsXG4gIG1vZGFsTWVzc2FnZTogJ1JldHJpZXZpbmcgRG9jdW1lbnQuLi4nLFxuICBmcmFtZUlkOiAncHJpbnRKUycsXG4gIGJvcmRlcjogdHJ1ZSxcbiAgaHRtbERhdGE6ICcnXG59XG5cbmxldCBwcmludEZyaWVuZGx5RWxlbWVudCwgYm9keVN0eWxlLCBoZWFkZXJTdHlsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY2hlY2sgaWYgYSBwcmludGFibGUgZG9jdW1lbnQgb3Igb2JqZWN0IHdhcyBzdXBwbGllZFxuICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB3aW5kb3cuY29uc29sZS5lcnJvcigncHJpbnRKUyBleHBlY3RzIGF0IGxlYXN0IDEgYXR0cmlidXRlLicpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBpbnN0YW50aWF0ZSBwcmludCBvYmplY3RcbiAgbGV0IHByaW50SlMgPSBuZXcgUHJpbnRKUyhhcmd1bWVudHMpXG5cbiAgLy8gcHJpbnQgZnJpZW5kbHkgZGVmYXVsdHNcbiAgcHJpbnRGcmllbmRseUVsZW1lbnQgPSAnbWF4LXdpZHRoOiAnICsgcHJpbnRKUy5wYXJhbXMubWF4V2lkdGggKyAncHggIWltcG9ydGFudDsnICsgcHJpbnRKUy5wYXJhbXMuZm9udF9zaXplICsgJyAhaW1wb3J0YW50OydcbiAgYm9keVN0eWxlID0gJ2ZvbnQtZmFtaWx5OicgKyBwcmludEpTLnBhcmFtcy5mb250ICsgJyAhaW1wb3J0YW50OyBmb250LXNpemU6ICcgKyBwcmludEpTLnBhcmFtcy5mb250X3NpemUgKyAnICFpbXBvcnRhbnQ7IHdpZHRoOjEwMCU7J1xuICBoZWFkZXJTdHlsZSA9ICdmb250LXdlaWdodDozMDA7J1xuXG4gIC8vIGNoZWNrIHByaW50YWJsZSB0eXBlXG4gIHN3aXRjaCAocHJpbnRKUy5wYXJhbXMudHlwZSkge1xuICAgIGNhc2UgJ3BkZic6XG4gICAgICAgICAgLy8gZmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgaWZyYW1lIHByaW50aW5nLCB3ZSB3aWxsIGp1c3Qgb3BlbiB0aGUgcGRmIGZpbGUgaW5zdGVhZFxuICAgICAgaWYgKGJyb3dzZXIuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ByaW50SlMgZG9lc25cXCd0IHN1cHBvcnQgUERGIHByaW50aW5nIGluIEZpcmVmb3guJylcbiAgICAgICAgbGV0IHdpbiA9IHdpbmRvdy5vcGVuKHByaW50SlMucGFyYW1zLnByaW50YWJsZSwgJ19ibGFuaycpXG4gICAgICAgIHdpbi5mb2N1cygpXG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBsb2FkaW5nIG1vZGFsIG9wZW5lZFxuICAgICAgICBpZiAocHJpbnRKUy5wYXJhbXMuc2hvd01vZGFsKSBwcmludEpTLmRpc2FibGVQcmludE1vZGFsKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW50SlMucGRmKClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgcHJpbnRKUy5pbWFnZSgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgcHJpbnRKUy5odG1sKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnanNvbic6XG4gICAgICBwcmludEpTLmpzb24oKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHRocm93IGludmFsaWQgdHlwZSBlcnJvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaW50IHR5cGUuIEF2YWlsYWJsZSB0eXBlcyBhcmU6IHBkZiwgaHRtbCwgaW1hZ2UgYW5kIGpzb24uJylcbiAgfVxufVxuXG4vLyBwcmludEpTIGNsYXNzXG5sZXQgUHJpbnRKUyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGFyZ3MgPSBhcmd1bWVudHNbMF1cblxuICBsZXQgcHJpbnQgPSB0aGlzXG5cbiAgcHJpbnQucGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0UGFyYW1zKVxuXG4gIHN3aXRjaCAodHlwZW9mIGFyZ3NbMF0pIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbnQucGFyYW1zLnByaW50YWJsZSA9IGVuY29kZVVSSShhcmdzWzBdKVxuICAgICAgcHJpbnQucGFyYW1zLnR5cGUgPSBhcmdzWzFdIHx8IGRlZmF1bHRQYXJhbXMudHlwZVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBwcmludC5wYXJhbXMucHJpbnRhYmxlID0gYXJnc1swXS5wcmludGFibGVcbiAgICAgIHByaW50LnBhcmFtcy50eXBlID0gYXJnc1swXS50eXBlIHx8IGRlZmF1bHRQYXJhbXMudHlwZVxuICAgICAgcHJpbnQucGFyYW1zLmZyYW1lSWQgPSBhcmdzWzBdLmZyYW1lSWQgfHwgZGVmYXVsdFBhcmFtcy5mcmFtZUlkXG4gICAgICBwcmludC5wYXJhbXMuaGVhZGVyID0gYXJnc1swXS5oZWFkZXIgfHwgZGVmYXVsdFBhcmFtcy5oZWFkZXJcbiAgICAgIHByaW50LnBhcmFtcy5tYXhXaWR0aCA9IGFyZ3NbMF0ubWF4V2lkdGggfHwgZGVmYXVsdFBhcmFtcy5tYXhXaWR0aFxuICAgICAgcHJpbnQucGFyYW1zLmZvbnQgPSBhcmdzWzBdLmZvbnQgfHwgZGVmYXVsdFBhcmFtcy5mb250XG4gICAgICBwcmludC5wYXJhbXMuZm9udF9zaXplID0gYXJnc1swXS5mb250X3NpemUgfHwgZGVmYXVsdFBhcmFtcy5mb250X3NpemVcbiAgICAgIHByaW50LnBhcmFtcy5ob25vck1hcmdpblBhZGRpbmcgPSAodHlwZW9mIGFyZ3NbMF0uaG9ub3JNYXJnaW5QYWRkaW5nICE9PSAndW5kZWZpbmVkJykgPyBhcmdzWzBdLmhvbm9yTWFyZ2luUGFkZGluZyA6IGRlZmF1bHRQYXJhbXMuaG9ub3JNYXJnaW5QYWRkaW5nXG4gICAgICBwcmludC5wYXJhbXMucHJvcGVydGllcyA9IGFyZ3NbMF0ucHJvcGVydGllcyB8fCBkZWZhdWx0UGFyYW1zLnByb3BlcnRpZXNcbiAgICAgIHByaW50LnBhcmFtcy5zaG93TW9kYWwgPSAodHlwZW9mIGFyZ3NbMF0uc2hvd01vZGFsICE9PSAndW5kZWZpbmVkJykgPyBhcmdzWzBdLnNob3dNb2RhbCA6IGRlZmF1bHRQYXJhbXMuc2hvd01vZGFsXG4gICAgICBwcmludC5wYXJhbXMubW9kYWxNZXNzYWdlID0gYXJnc1swXS5tb2RhbE1lc3NhZ2UgfHwgZGVmYXVsdFBhcmFtcy5tb2RhbE1lc3NhZ2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50IHR5cGUhIEV4cGVjdGVkIFwic3RyaW5nXCIgb3IgXCJvYmplY3RcIiwgZ290ICcgKyB0eXBlb2YgYXJnc1swXSlcbiAgfVxuXG4gIC8vIHNvbWUgdmFsaWRhdGlvblxuICBwcmludC52YWxpZGF0ZUlucHV0KClcblxuICAvLyBjaGVjayBpZiBzaG93aW5nIGZlZWRiYWNrIHRvIHVzZXIgKHVzZWZ1bCBmb3IgbGFyZ2UgZmlsZXMpXG4gIGlmIChwcmludC5wYXJhbXMuc2hvd01vZGFsKSB7XG4gICAgcHJpbnQuc2hvd01vZGFsKClcbiAgfVxuXG4gIC8vIHRvIHByZXZlbnQgZHVwbGljYXRpb24gYW5kIGlzc3VlcywgcmVtb3ZlIHByaW50LnByaW50RnJhbWUgZnJvbSBET00sIGlmIGl0IGV4aXN0c1xuICBsZXQgdXNlZEZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJpbnQucGFyYW1zLmZyYW1lSWQpXG5cbiAgaWYgKHVzZWRGcmFtZSkge1xuICAgIHVzZWRGcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVzZWRGcmFtZSlcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIG5ldyBpZnJhbWUgb3IgZW1iZWQgZWxlbWVudCAoSUUgcHJpbnRzIGJsYW5rIHBkZidzIGlmIHdlIHVzZSBpZnJhbWUpXG4gIGlmIChicm93c2VyLmlzSUUoKSAmJiBwcmludC5wYXJhbXMudHlwZSA9PT0gJ3BkZicpIHtcbiAgICAvLyBjcmVhdGUgZW1iZWQgZWxlbWVudFxuICAgIHByaW50LnByaW50RnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdlbWJlZCcpXG4gICAgcHJpbnQucHJpbnRGcmFtZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYXBwbGljYXRpb24vcGRmJylcblxuICAgIC8vIGhpZGUgZW1iZWRcbiAgICBwcmludC5wcmludEZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6MHB4O2hlaWdodDowcHg7JylcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgaWZyYW1lIGVsZW1lbnRcbiAgICBwcmludC5wcmludEZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcblxuICAgIC8vIGhpZGUgaWZyYW1lXG4gICAgcHJpbnQucHJpbnRGcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZTsnKVxuICB9XG5cbiAgLy8gc2V0IGVsZW1lbnQgaWRcbiAgcHJpbnQucHJpbnRGcmFtZS5zZXRBdHRyaWJ1dGUoJ2lkJywgcHJpbnQucGFyYW1zLmZyYW1lSWQpXG5cbiAgLy8gZm9yIG5vbiBwZGYgcHJpbnRpbmcsIHBhc3MgZW1wdHkgaHRtbCBkb2N1bWVudCB0byBzcmNkb2MgKGZvcmNlIG9ubG9hZCBjYWxsYmFjaylcbiAgaWYgKHByaW50LnBhcmFtcy50eXBlICE9PSAncGRmJykgcHJpbnQucHJpbnRGcmFtZS5zcmNkb2MgPSAnPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+J1xufVxuXG5QcmludEpTLnByb3RvdHlwZS5wZGYgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHByaW50ID0gdGhpc1xuXG4gIC8vIGlmIHNob3dpbmcgZmVlZGJhY2sgdG8gdXNlciwgcHJlIGxvYWQgcGRmIGZpbGVzIChoYWNreSlcbiAgLy8gc2luY2Ugd2Ugd2lsbCBiZSB1c2luZyBwcm9taXNlcywgd2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBpbiBJRVxuICBpZiAocHJpbnQucGFyYW1zLnNob3dNb2RhbCAmJiAhYnJvd3Nlci5pc0lFKCkpIHtcbiAgICBsZXQgcGRmT2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICBwZGZPYmplY3Quc3JjID0gcHJpbnQucGFyYW1zLnByaW50YWJsZVxuXG4gICAgbGV0IHBkZiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxldCBsb2FkUERGID0gc2V0SW50ZXJ2YWwoY2hlY2tQREZsb2FkLCAxMDApXG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUERGbG9hZCAoKSB7XG4gICAgICAgIGlmIChwZGZPYmplY3QuY29tcGxldGUpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChsb2FkUERGKVxuICAgICAgICAgIHJlc29sdmUoJ1ByaW50SlM6IFBERiBsb2FkZWQuIFJlYWQgdG8gcHJpbnQuJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBwZGYudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBjb25zb2xlLmxvZyhyZXN1bHQpXG4gICAgICAvLyBzZXQgaWZyYW1lIHNyYyB3aXRoIHBkZiBkb2N1bWVudCB1cmxcbiAgICAgIHByaW50LnByaW50RnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCBwcmludC5wYXJhbXMucHJpbnRhYmxlKVxuXG4gICAgICAvLyBwcmludCBwZGYgZG9jdW1lbnRcbiAgICAgIHByaW50LnByaW50KClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIHNldCBpZnJhbWUgc3JjIHdpdGggcGRmIGRvY3VtZW50IHVybFxuICAgIHByaW50LnByaW50RnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCBwcmludC5wYXJhbXMucHJpbnRhYmxlKVxuXG4gICAgLy8gcHJpbnQgcGRmXG4gICAgcHJpbnQucHJpbnQoKVxuICB9XG59XG5cblByaW50SlMucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgdGhlIGltYWdlIGVsZW1lbnRcbiAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gIGltZy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOjEwMCU7JylcbiAgaW1nLnNldEF0dHJpYnV0ZSgnaWQnLCAncHJpbnRhYmxlSW1hZ2UnKVxuXG4gIC8vIHNldCBpbWFnZSBzcmMgd2l0aCBpbWFnZSBmaWxlIHVybFxuICBpbWcuc3JjID0gdGhpcy5wYXJhbXMucHJpbnRhYmxlXG5cbiAgLy8gYXNzaWduIGB0aGlzYCB0byBhIHZhcmlhYmxlLCB0byBiZSB1c2VkIHdpdGhpbiB0aGUgcHJvbWlzZSwgYW5kIGZ1bmN0aW9uc1xuICBsZXQgc2VsZiA9IHRoaXNcblxuICAvLyBjcmVhdGUgd3JhcHBlclxuICBsZXQgcHJpbnRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHByaW50YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICd3aWR0aDoxMDAlJylcblxuICAvLyB0byBwcmV2ZW50IGZpcmVmb3ggZnJvbSBub3QgbG9hZGluZyBpbWFnZXMgd2l0aGluIGlmcmFtZSwgd2UgY2FuIHVzZSBiYXNlNjQtZW5jb2RlZCBkYXRhIFVSTCBvZiBpbWFnZXMgcGl4ZWwgZGF0YVxuICBpZiAoYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgIC8vIGxldCdzIG1ha2UgZmlyZWZveCBoYXBweVxuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaW1nLndpZHRoKVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGltZy5oZWlnaHQpXG4gICAgbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcblxuICAgIC8vIHJlc2V0IGltZyBzcmMgYXR0cmlidXRlIHdpdGggY2FudmFzIGRhdGFVUkxcbiAgICBpbWcuc2V0QXR0cmlidXRlKCdzcmMnLCBjYW52YXMudG9EYXRhVVJMKCdKUEVHJywgMS4wKSlcbiAgfVxuXG4gIHByaW50YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoaW1nKVxuXG4gIC8vIGFkZCBoZWFkZXIgaWYgYW55XG4gIGlmIChzZWxmLnBhcmFtcy5oZWFkZXIpIHtcbiAgICBzZWxmLmFkZEhlYWRlcihwcmludGFibGVFbGVtZW50KVxuICB9XG5cbiAgLy8gc3RvcmUgaHRtbCBkYXRhXG4gIHNlbGYucGFyYW1zLmh0bWxEYXRhID0gcHJpbnRhYmxlRWxlbWVudC5vdXRlckhUTUxcblxuICAvLyBwcmludCBpbWFnZVxuICBzZWxmLnByaW50KClcbn1cblxuUHJpbnRKUy5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZ2V0IEhUTUwgcHJpbnRhYmxlIGVsZW1lbnRcbiAgbGV0IHByaW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMucGFyYW1zLnByaW50YWJsZSlcblxuICAvLyBjaGVjayBpZiBlbGVtZW50IGV4aXN0c1xuICBpZiAoIXByaW50RWxlbWVudCkge1xuICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKCdJbnZhbGlkIEhUTUwgZWxlbWVudCBpZDogJyArIHRoaXMucGFyYW1zLnByaW50YWJsZSlcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIHByaW50RWxlbWVudCB0byBwcmV2ZW50IERPTSBjaGFuZ2VzXG4gIGxldCBwcmludGFibGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgcHJpbnRhYmxlRWxlbWVudC5hcHBlbmRDaGlsZChwcmludEVsZW1lbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gIC8vIGFkZCBjbG9uZWQgZWxlbWVudCB0byBET00sIHRvIGhhdmUgRE9NIGVsZW1lbnQgbWV0aG9kcyBhdmFpbGFibGUuIEl0IHdpbGwgYWxzbyBiZSBlYXNpZXIgdG8gY29sZWN0IHN0eWxlc1xuICBwcmludGFibGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOycpXG4gIHByaW50YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsICdwcmludEpTLWh0bWwnKVxuICBwcmludEVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwcmludGFibGVFbGVtZW50KVxuXG4gIC8vIHVwZGF0ZSBwcmludGFibGVFbGVtZW50IHZhcmlhYmxlIHdpdGggbmV3bHkgY3JlYXRlZCBET00gZWxlbWVudFxuICBwcmludGFibGVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByaW50SlMtaHRtbCcpXG5cbiAgLy8gZ2V0IG1haW4gZWxlbWVudCBzdHlsaW5nXG4gIHByaW50YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuY29sbGVjdFN0eWxlcyhwcmludGFibGVFbGVtZW50KSArICdtYXJnaW46MCAhaW1wb3J0YW50OycpXG5cbiAgLy8gZ2V0IGFsbCBjaGlsZHJlbiBlbGVtZW50c1xuICBsZXQgZWxlbWVudHMgPSBwcmludGFibGVFbGVtZW50LmNoaWxkcmVuXG5cbiAgLy8gZ2V0IHN0eWxlcyBmb3IgYWxsIGNoaWxkcmVuIGVsZW1lbnRzXG4gIHRoaXMubG9vcE5vZGVzQ29sbGVjdFN0eWxlcyhlbGVtZW50cylcblxuICAvLyBhZGQgaGVhZGVyIGlmIGFueVxuICBpZiAodGhpcy5wYXJhbXMuaGVhZGVyKSB7XG4gICAgdGhpcy5hZGRIZWFkZXIocHJpbnRhYmxlRWxlbWVudClcbiAgfVxuXG4gIC8vIHJlbW92ZSBET00gcHJpbnRhYmxlRWxlbWVudFxuICBwcmludGFibGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJpbnRhYmxlRWxlbWVudClcblxuICAvLyBzdG9yZSBodG1sIGRhdGFcbiAgdGhpcy5wYXJhbXMuaHRtbERhdGEgPSBhZGRXcmFwcGVyKHByaW50YWJsZUVsZW1lbnQuaW5uZXJIVE1MKVxuXG4gIC8vIHByaW50IGh0bWwgZWxlbWVudCBjb250ZW50c1xuICB0aGlzLnByaW50KClcbn1cblxuUHJpbnRKUy5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgIC8vIGNoZWNrIGlmIHdlIHJlY2VpdmVkIHByb3BlciBkYXRhXG4gIGlmICh0eXBlb2YgdGhpcy5wYXJhbXMucHJpbnRhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBqYXZhc2NyaXB0IGRhdGEgb2JqZWN0IChKU09OKS4nKVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgcHJvcGVydGllcyB3ZXJlIHByb3ZpZGVkXG4gIGlmICghdGhpcy5wYXJhbXMucHJvcGVydGllcyB8fCB0eXBlb2YgdGhpcy5wYXJhbXMucHJvcGVydGllcyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydGllcyBhcnJheSBmb3IgeW91ciBKU09OIGRhdGEuJylcbiAgfVxuXG4gIC8vIHZhcmlhYmxlIHRvIGhvbGQgaHRtbCBzdHJpbmdcbiAgbGV0IGh0bWxEYXRhID0gJydcblxuICAvLyBjaGVjayBwcmludCBoYXMgaGVhZGVyXG4gIGlmICh0aGlzLnBhcmFtcy5oZWFkZXIpIHtcbiAgICBodG1sRGF0YSArPSAnPGgxIHN0eWxlPVwiJyArIGhlYWRlclN0eWxlICsgJ1wiPicgKyB0aGlzLnBhcmFtcy5oZWFkZXIgKyAnPC9oMT4nXG4gIH1cblxuICAvLyBmdW5jdGlvbiB0byBidWlsZCBodG1sIHRlbXBsYXRlcyBmb3IganNvbiBkYXRhXG4gIGh0bWxEYXRhICs9IHRoaXMuanNvblRvSFRNTCgpXG5cbiAgLy8gc3RvcmUgaHRtbCBkYXRhXG4gIHRoaXMucGFyYW1zLmh0bWxEYXRhID0gYWRkV3JhcHBlcihodG1sRGF0YSlcblxuICAvLyBwcmludCBqc29uIGRhdGFcbiAgdGhpcy5wcmludCgpXG59XG5cblByaW50SlMucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgcHJpbnQgPSB0aGlzXG5cbiAgLy8gYXBwZW5kIGlmcmFtZSBlbGVtZW50IHRvIGRvY3VtZW50IGJvZHlcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXS5hcHBlbmRDaGlsZChwcmludC5wcmludEZyYW1lKVxuXG4gIC8vIGdldCBpZnJhbWUgZWxlbWVudFxuICBsZXQgcHJpbnRKUyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByaW50LnBhcmFtcy5mcmFtZUlkKVxuXG4gIC8vIGlmIHByaW50aW5nIHBkZiBpbiBJRVxuICBpZiAoYnJvd3Nlci5pc0lFKCkgJiYgcHJpbnQucGFyYW1zLnR5cGUgPT09ICdwZGYnKSB7XG4gICAgZmluaXNoUHJpbnRQZGZJZSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gd2FpdCBmb3IgaWZyYW1lIHRvIGxvYWQgYWxsIGNvbnRlbnRcbiAgICBwcmludC5wcmludEZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcmludC5wYXJhbXMudHlwZSA9PT0gJ3BkZicpIHtcbiAgICAgICAgZmluaXNoUHJpbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0IGlmcmFtZSBlbGVtZW50IGRvY3VtZW50XG4gICAgICAgIGxldCBwcmludERvY3VtZW50ID0gKHByaW50SlMuY29udGVudFdpbmRvdyB8fCBwcmludEpTLmNvbnRlbnREb2N1bWVudClcbiAgICAgICAgaWYgKHByaW50RG9jdW1lbnQuZG9jdW1lbnQpIHByaW50RG9jdW1lbnQgPSBwcmludERvY3VtZW50LmRvY3VtZW50XG5cbiAgICAgICAgLy8gaW5qZWN0IHByaW50YWJsZSBodG1sIGludG8gaWZyYW1lIGJvZHlcbiAgICAgICAgcHJpbnREb2N1bWVudC5ib2R5LmlubmVySFRNTCA9IHByaW50LnBhcmFtcy5odG1sRGF0YVxuXG4gICAgICAgIC8vIHdhaXQgZm9yIGltYWdlIHRvIGxvYWQgaW5zaWRlIGlmcmFtZSAoY2hyb21lIG9ubHkpXG4gICAgICAgIGlmIChwcmludC5wYXJhbXMudHlwZSA9PT0gJ2ltYWdlJyAmJiBicm93c2VyLmlzQ2hyb21lKCkpIHtcbiAgICAgICAgICBwcmludERvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmludGFibGVJbWFnZScpLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZpbmlzaFByaW50KClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluaXNoUHJpbnQoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoUHJpbnQgKCkge1xuICAgIC8vIHByaW50IGlmcmFtZSBkb2N1bWVudFxuICAgIHByaW50SlMuZm9jdXMoKVxuXG4gICAgLy8gaWYgSUUsIHRyeSBjYXRjaCB3aXRoIGV4ZWNDb21tYW5kXG4gICAgaWYgKGJyb3dzZXIuaXNJRSgpICYmIHByaW50LnBhcmFtcy50eXBlICE9PSAncGRmJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJpbnRKUy5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKCdwcmludCcsIGZhbHNlLCBudWxsKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcmludEpTLmNvbnRlbnRXaW5kb3cucHJpbnQoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmludEpTLmNvbnRlbnRXaW5kb3cucHJpbnQoKVxuICAgIH1cblxuICAgIC8vIGlmIHNob3dpbmcgZmVlZGJhY2sgdG8gdXNlciwgcmVtb3ZlIHByb2Nlc3NpbmcgbWVzc2FnZSAoY2xvc2UgbW9kYWwpXG4gICAgaWYgKHByaW50LnBhcmFtcy5zaG93TW9kYWwpIHtcbiAgICAgIHByaW50LmRpc2FibGVQcmludE1vZGFsKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hQcmludFBkZkllICgpIHtcbiAgICAvLyB3YWl0IHVudGlsIHBkZiBpcyByZWFkeSB0byBwcmludFxuICAgIGlmICh0eXBlb2YgcHJpbnRKUy5wcmludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBmaW5pc2hQcmludFBkZkllKCkgfSwgMTAwMClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRKUy5wcmludCgpXG5cbiAgICAgIC8vIHJlbW92ZSBlbWJlZCAoanVzdCBiZWNhdXNlIGl0IGlzbid0IDEwMCUgaGlkZGVuIHdoZW4gdXNpbmcgaC93ID0gMClcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBwcmludEpTLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJpbnRKUykgfSwgMjAwMClcbiAgICB9XG4gIH1cbn1cblxuUHJpbnRKUy5wcm90b3R5cGUuY29sbGVjdFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGxldCB3aW4gPSBkb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3dcblxuICBsZXQgc3R5bGUgPSBbXVxuXG4gIC8vIHN0cmluZyB2YXJpYWJsZSB0byBob2xkIHN0eWxpbmcgZm9yIGVhY2ggZWxlbWVudFxuICBsZXQgZWxlbWVudFN0eWxlID0gJydcblxuICBpZiAod2luLmdldENvbXB1dGVkU3R5bGUpIHsgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgc3R5bGUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJylcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHN0eWxlcyBpbmNsdWRpbmdcbiAgICAgIGxldCB0YXJnZXRTdHlsZXMgPSBbJ2JvcmRlcicsICdmbG9hdCcsICdib3gnXVxuXG4gICAgICAvLyBleGFjdFxuICAgICAgbGV0IHRhcmdldFN0eWxlID0gWydjbGVhcicsICdkaXNwbGF5JywgJ3dpZHRoJywgJ21pbi13aWR0aCcsICdoZWlnaHQnLCAnbWluLWhlaWdodCcsICdtYXgtaGVpZ2h0J11cblxuICAgICAgLy8gb3B0aW5hbCAtIGluY2x1ZGUgbWFyZ2luIGFuZCBwYWRkaW5nXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaG9ub3JNYXJnaW5QYWRkaW5nKSB7XG4gICAgICAgIHRhcmdldFN0eWxlLnB1c2goJ21hcmdpbicsICdwYWRkaW5nJylcbiAgICAgIH1cblxuICAgICAgLy8gb3B0aW5hbCAtIGluY2x1ZGUgY29sb3JcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5ob25vckNvbG9yKSB7XG4gICAgICAgIHRhcmdldFN0eWxlLnB1c2goJ2NvbG9yJylcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0YXJnZXRTdHlsZS5sZW5ndGg7IHMrKykge1xuICAgICAgICBpZiAoc3R5bGVbaV0uaW5kZXhPZih0YXJnZXRTdHlsZXNbc10pICE9PSAtMSB8fCBzdHlsZVtpXS5pbmRleE9mKHRhcmdldFN0eWxlW3NdKSA9PT0gMCkge1xuICAgICAgICAgIGVsZW1lbnRTdHlsZSArPSBzdHlsZVtpXSArICc6JyArIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVbaV0pICsgJzsnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUpIHsgLy8gSUVcbiAgICBzdHlsZSA9IGVsZW1lbnQuY3VycmVudFN0eWxlXG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHN0eWxlKSB7XG4gICAgICBpZiAoc3R5bGUuaW5kZXhPZignYm9yZGVyJykgIT09IC0xICYmIHN0eWxlLmluZGV4T2YoJ2NvbG9yJykgIT09IC0xKSB7XG4gICAgICAgIGVsZW1lbnRTdHlsZSArPSBuYW1lICsgJzonICsgc3R5bGVbbmFtZV0gKyAnOydcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGQgcHJpbnRlciBmcmllbmRseVxuICBlbGVtZW50U3R5bGUgKz0gcHJpbnRGcmllbmRseUVsZW1lbnRcblxuICByZXR1cm4gZWxlbWVudFN0eWxlXG59XG5cblByaW50SlMucHJvdG90eXBlLmxvb3BOb2Rlc0NvbGxlY3RTdHlsZXMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBlbGVtZW50cy5sZW5ndGg7IG4rKykge1xuICAgIGxldCBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnRzW25dXG5cbiAgICAvLyBGb3JtIFByaW50aW5nIC0gY2hlY2sgaWYgaXMgZWxlbWVudCBJbnB1dFxuICAgIGxldCB0YWcgPSBjdXJyZW50RWxlbWVudC50YWdOYW1lXG4gICAgaWYgKHRhZyA9PT0gJ0lOUFVUJyB8fCB0YWcgPT09ICdURVhUQVJFQScgfHwgdGFnID09PSAnU0VMRUNUJykge1xuICAgICAgLy8gc2F2ZSBzdHlsZSB0byB2YXJpYWJsZVxuICAgICAgbGV0IHRleHRTdHlsZSA9IHRoaXMuY29sbGVjdFN0eWxlcyhjdXJyZW50RWxlbWVudClcblxuICAgICAgLy8gcmVtb3ZlIElOUFVUIGVsZW1lbnQgYW5kIGluc2VydCBhIHRleHQgbm9kZVxuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudE5vZGVcblxuICAgICAgLy8gZ2V0IHRleHQgdmFsdWVcbiAgICAgIGxldCB0ZXh0Tm9kZSA9IHRhZyA9PT0gJ1NFTEVDVCdcbiAgICAgICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjdXJyZW50RWxlbWVudC5vcHRpb25zW2N1cnJlbnRFbGVtZW50LnNlbGVjdGVkSW5kZXhdLnRleHQpXG4gICAgICAgICAgICAgIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VycmVudEVsZW1lbnQudmFsdWUpXG5cbiAgICAgIC8vIGNyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICAgIGxldCB0ZXh0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICB0ZXh0RWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcblxuICAgICAgLy8gYWRkIHN0eWxlIHRvIHRleHRcbiAgICAgIHRleHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0ZXh0U3R5bGUpXG5cbiAgICAgIC8vIGFkZCB0ZXh0XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpXG5cbiAgICAgIC8vIHJlbW92ZSBpbnB1dFxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGN1cnJlbnRFbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgYWxsIHN0eWxpbmcgZm9yIHByaW50IGVsZW1lbnRcbiAgICAgIGN1cnJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0aGlzLmNvbGxlY3RTdHlsZXMoY3VycmVudEVsZW1lbnQpKVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIG1vcmUgZWxlbWVudHMgaW4gdHJlZVxuICAgIGxldCBjaGlsZHJlbiA9IGN1cnJlbnRFbGVtZW50LmNoaWxkcmVuXG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvb3BOb2Rlc0NvbGxlY3RTdHlsZXMoY2hpbGRyZW4pXG4gICAgfVxuICB9XG59XG5cblByaW50SlMucHJvdG90eXBlLmFkZEhlYWRlciA9IGZ1bmN0aW9uIChwcmludEVsZW1lbnQpIHtcbiAgLy8gY3JlYXRlIGhlYWRlciBlbGVtZW50XG4gIGxldCBoZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKVxuXG4gIC8vIGNyZWF0ZSBoZWFkZXIgdGV4dCBub2RlXG4gIGxldCBoZWFkZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5wYXJhbXMuaGVhZGVyKVxuXG4gIC8vIGJ1aWxkIGFuZCBzdHlsZVxuICBoZWFkZXJFbGVtZW50LmFwcGVuZENoaWxkKGhlYWRlck5vZGUpXG4gIGhlYWRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsIGhlYWRlclN0eWxlKVxuXG4gIHByaW50RWxlbWVudC5pbnNlcnRCZWZvcmUoaGVhZGVyRWxlbWVudCwgcHJpbnRFbGVtZW50LmNoaWxkTm9kZXNbMF0pXG59XG5cblByaW50SlMucHJvdG90eXBlLmpzb25Ub0hUTUwgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBkYXRhID0gdGhpcy5wYXJhbXMucHJpbnRhYmxlXG4gIGxldCBwcm9wZXJ0aWVzID0gdGhpcy5wYXJhbXMucHJvcGVydGllc1xuXG4gIGxldCBodG1sRGF0YSA9ICc8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1wiPidcblxuICAvLyBoZWFkZXJcbiAgaHRtbERhdGEgKz0gJzxkaXYgc3R5bGU9XCJmbGV4OjE7IGRpc3BsYXk6ZmxleDtcIj4nXG5cbiAgZm9yIChsZXQgYSA9IDA7IGEgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgYSsrKSB7XG4gICAgaHRtbERhdGEgKz0gJzxkaXYgc3R5bGU9XCJmbGV4OjE7IHBhZGRpbmc6NXB4O1wiPicgKyBjYXBpdGFsaXplUHJpbnQocHJvcGVydGllc1thXSkgKyAnPC9kaXY+J1xuICB9XG5cbiAgaHRtbERhdGEgKz0gJzwvZGl2PidcblxuICAvLyBjcmVhdGUgaHRtbCBkYXRhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGh0bWxEYXRhICs9ICc8ZGl2IHN0eWxlPVwiZmxleDoxOyBkaXNwbGF5OmZsZXg7J1xuICAgIGh0bWxEYXRhICs9IHRoaXMucGFyYW1zLmJvcmRlciA/ICdib3JkZXI6MXB4IHNvbGlkIGxpZ2h0Z3JheTsnIDogJydcbiAgICBodG1sRGF0YSArPSAnXCI+J1xuXG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBwcm9wZXJ0aWVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBodG1sRGF0YSArPSAnPGRpdiBzdHlsZT1cImZsZXg6MTsgcGFkZGluZzo1cHg7XCI+JyArIGRhdGFbaV1bcHJvcGVydGllc1tuXV0gKyAnPC9kaXY+J1xuICAgIH1cblxuICAgIGh0bWxEYXRhICs9ICc8L2Rpdj4nXG4gIH1cblxuICBodG1sRGF0YSArPSAnPC9kaXY+J1xuXG4gIHJldHVybiBodG1sRGF0YVxufVxuXG5QcmludEpTLnByb3RvdHlwZS52YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGFyYW1zLnByaW50YWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcmludGFibGUgaW5mb3JtYXRpb24uJylcbiAgfVxuXG4gIGlmICghdGhpcy5wYXJhbXMudHlwZSB8fCB0eXBlb2YgdGhpcy5wYXJhbXMudHlwZSAhPT0gJ3N0cmluZycgfHwgcHJpbnRUeXBlcy5pbmRleE9mKHRoaXMucGFyYW1zLnR5cGUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaW50IHR5cGUuIEF2YWlsYWJsZSB0eXBlcyBhcmU6IHBkZiwgaHRtbCwgaW1hZ2UgYW5kIGpzb24uJylcbiAgfVxufVxuXG5QcmludEpTLnByb3RvdHlwZS5zaG93TW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGJ1aWxkIG1vZGFsXG4gIGxldCBtb2RhbFN0eWxlID0gJ2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7ICcgK1xuICAgICAgJ2Rpc3BsYXk6dGFibGU7ICcgK1xuICAgICAgJ3RleHQtYWxpZ246Y2VudGVyOyAnICtcbiAgICAgICdmb250LXdlaWdodDozMDA7ICcgK1xuICAgICAgJ2ZvbnQtc2l6ZTozMHB4OyAnICtcbiAgICAgICdsZWZ0OjA7IHRvcDowOycgK1xuICAgICAgJ3Bvc2l0aW9uOmZpeGVkOyAnICtcbiAgICAgICd6LWluZGV4OiA5OTkwOycgK1xuICAgICAgJ2NvbG9yOiAjMDQ2MEI1OyAnICtcbiAgICAgICd3aWR0aDogMTAwJTsgJyArXG4gICAgICAnaGVpZ2h0OiAxMDAlOyAnICtcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjU1LDI1NSwyNTUsLjkpOycgK1xuICAgICAgJ3RyYW5zaXRpb246IG9wYWNpdHkgLjNzIGVhc2U7J1xuXG4gIC8vIGNyZWF0ZSB3cmFwcGVyXG4gIGxldCBwcmludE1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgcHJpbnRNb2RhbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgbW9kYWxTdHlsZSlcbiAgcHJpbnRNb2RhbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3ByaW50SlMtTW9kYWwnKVxuXG4gIC8vIGNyZWF0ZSBjb250ZW50IGRpdlxuICBsZXQgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRlbnREaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OnRhYmxlLWNlbGw7IHZlcnRpY2FsLWFsaWduOm1pZGRsZTsgcGFkZGluZy1ib3R0b206MTAwcHg7JylcblxuICAvLyBhZGQgY2xvc2UgYnV0dG9uIChyZXF1aXJlcyBwcmludC5jc3MpXG4gIGxldCBjbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAncHJpbnRDbG9zZScpXG4gIGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnaWQnLCAncHJpbnRDbG9zZScpXG4gIGNvbnRlbnREaXYuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24pXG5cbiAgLy8gYWRkIHNwaW5uZXIgKHJlcXVpcmVzIHByaW50LmNzcylcbiAgbGV0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgc3Bpbm5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3ByaW50U3Bpbm5lcicpXG4gIGNvbnRlbnREaXYuYXBwZW5kQ2hpbGQoc3Bpbm5lcilcblxuICAvLyBhZGQgbWVzc2FnZVxuICBsZXQgbWVzc2FnZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnBhcmFtcy5tb2RhbE1lc3NhZ2UpXG4gIGNvbnRlbnREaXYuYXBwZW5kQ2hpbGQobWVzc2FnZU5vZGUpXG5cbiAgLy8gYWRkIGNvbnRlbnREaXYgdG8gcHJpbnRNb2RhbFxuICBwcmludE1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnREaXYpXG5cbiAgLy8gYXBwZW5kIHByaW50IG1vZGFsIGVsZW1lbnQgdG8gZG9jdW1lbnQgYm9keVxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLmFwcGVuZENoaWxkKHByaW50TW9kYWwpXG5cbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvIGNsb3NlIGJ1dHRvblxuICBsZXQgcHJpbnQgPSB0aGlzXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmludENsb3NlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgcHJpbnQuZGlzYWJsZVByaW50TW9kYWwoKVxuICB9KVxufVxuXG5QcmludEpTLnByb3RvdHlwZS5kaXNhYmxlUHJpbnRNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHByaW50RnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJpbnRKUy1Nb2RhbCcpXG5cbiAgcHJpbnRGcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByaW50RnJhbWUpXG59XG5cbmZ1bmN0aW9uIGFkZFdyYXBwZXIgKGh0bWxEYXRhKSB7XG4gIHJldHVybiAnPGRpdiBzdHlsZT1cIicgKyBib2R5U3R5bGUgKyAnXCI+JyArIGh0bWxEYXRhICsgJzwvZGl2Pidcbn1cblxuLy8gdXBkYXRlIGRlZmF1bHQgcHJpbnQucGFyYW1zIHdpdGggdXNlciBpbnB1dFxuZnVuY3Rpb24gZXh0ZW5kIChhLCBiKSB7XG4gIGZvciAobGV0IGtleSBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgYVtrZXldID0gYltrZXldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFcbn1cblxuLy8gY2FwaXRhbGl6ZSBzdHJpbmdcbmZ1bmN0aW9uIGNhcGl0YWxpemVQcmludCAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSlcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9qcy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

eval("// Firefox 1.0+\nmodule.exports = {\n  isFirefox: function () {\n    return typeof InstallTrigger !== 'undefined'\n  },\n\n  // Internet Explorer 6-11\n  isIE: function () {\n    return !!document.documentMode\n  },\n\n  // Edge 20+\n  isEdge: function () {\n    return !this.isIE() && !!window.StyleMedia\n  },\n\n  // Chrome 1+\n  isChrome: function () {\n    return !!window.chrome && !!window.chrome.webstore\n  }\n\n  // Opera 8.0+\n  // let isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0\n\n  // At least Safari 3+: \"[object HTMLElementConstructor]\"\n  // let isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvYnJvd3Nlci5qcz84M2I5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpcmVmb3ggMS4wK1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRmlyZWZveDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnXG4gIH0sXG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgNi0xMVxuICBpc0lFOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlXG4gIH0sXG5cbiAgLy8gRWRnZSAyMCtcbiAgaXNFZGdlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzSUUoKSAmJiAhIXdpbmRvdy5TdHlsZU1lZGlhXG4gIH0sXG5cbiAgLy8gQ2hyb21lIDErXG4gIGlzQ2hyb21lOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhd2luZG93LmNocm9tZSAmJiAhIXdpbmRvdy5jaHJvbWUud2Vic3RvcmVcbiAgfVxuXG4gIC8vIE9wZXJhIDguMCtcbiAgLy8gbGV0IGlzT3BlcmEgPSAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDBcblxuICAvLyBBdCBsZWFzdCBTYWZhcmkgMys6IFwiW29iamVjdCBIVE1MRWxlbWVudENvbnN0cnVjdG9yXVwiXG4gIC8vIGxldCBpc1NhZmFyaSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2pzL2Jyb3dzZXIuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

eval("/*\n * Print.js\n * http://printjs.crabbly.com\n * Version: 1.0.12\n *\n * Copyright 2017 Rodrigo Vieira (@crabbly)\n * Released under the MIT license\n * https://github.com/crabbly/Print.js/blob/master/LICENSE\n */\n\nwindow.printJS = __webpack_require__(0)\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvcHJpbnQuanM/ZmEzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogUHJpbnQuanNcbiAqIGh0dHA6Ly9wcmludGpzLmNyYWJibHkuY29tXG4gKiBWZXJzaW9uOiAxLjAuMTJcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNyBSb2RyaWdvIFZpZWlyYSAoQGNyYWJibHkpXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcmFiYmx5L1ByaW50LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG53aW5kb3cucHJpbnRKUyA9IHJlcXVpcmUoJy4vanMvaW5kZXgnKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9wcmludC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFVQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);